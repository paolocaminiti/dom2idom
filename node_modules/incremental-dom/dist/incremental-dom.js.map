{"version":3,"sources":["incremental-dom.js","src/assertions.js","src/notifications.js","src/context.js","src/util.js","src/node_data.js","src/symbols.js","src/attributes.js","src/nodes.js","src/core.js","src/virtual_elements.js"],"names":[],"mappings":"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","file":"incremental-dom.js","sourcesContent":["\r\n/**\r\n * @license\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.IncrementalDOM = {}));\n}(this, function (exports) { 'use strict';\n\n  /**\r\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n   *\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *\r\n   *      http://www.apache.org/licenses/LICENSE-2.0\r\n   *\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n\r\n\r\n  /**\r\n    * Keeps track whether or not we are in an attributes declaration (after\r\n    * elementOpenStart, but before elementOpenEnd).\r\n    * @type {boolean}\r\n    */\r\n  var inAttributes = false;\r\n\r\n\r\n  /**\r\n   * Makes sure that there is a current patch context.\r\n   * @param {*} context\r\n   */\r\n  var assertInPatch = function(context) {\r\n    if (!context) {\r\n      throw new Error('Cannot call currentElement() unless in patch');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n  * Makes sure that keyed Element matches the tag name provided.\r\n  * @param {!Element} nodeName The nodeName of the node that is being matched.\r\n  * @param {string=} tag The tag name of the Element.\r\n  * @param {?string=} key The key of the Element.\r\n  */\r\n  var assertKeyedTagMatches = function(nodeName, tag, key) {\r\n    if (nodeName !== tag) {\r\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\r\n          tag + ', not a ' + nodeName + '.');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Makes sure that a patch closes every node that it opened.\r\n   * @param {!Node} openElement\r\n   * @param {!Node|!DocumentFragment} root\r\n   */\r\n  var assertNoUnclosedTags = function(openElement, root) {\r\n    if (openElement === root) {\r\n      return;\r\n    }\r\n\r\n    var openTags = [];\r\n    while (openElement && openElement !== root) {\r\n      openTags.push(openElement.nodeName.toLowerCase());\r\n      openElement = openElement.parentNode;\r\n    }\r\n\r\n    throw new Error('One or more tags were not closed:\\n' +\r\n        openTags.join('\\n'));\r\n  };\r\n\r\n\r\n  /**\r\n   * Makes sure that the caller is not where attributes are expected.\r\n   * @param {string} functionName\r\n   */\r\n  var assertNotInAttributes = function(functionName) {\r\n    if (inAttributes) {\r\n      throw new Error(functionName + '() may not be called between ' +\r\n          'elementOpenStart() and elementOpenEnd().');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Makes sure that the caller is where attributes are expected.\r\n   * @param {string} functionName\r\n   */\r\n  var assertInAttributes = function(functionName) {\r\n    if (!inAttributes) {\r\n      throw new Error(functionName + '() must be called after ' +\r\n          'elementOpenStart().');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Makes sure the patch closes virtual attributes call\r\n   */\r\n  var assertVirtualAttributesClosed = function() {\r\n    if (inAttributes) {\r\n      throw new Error('elementOpenEnd() must be called after calling ' +\r\n          'elementOpenStart().');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n    * Makes sure that placeholders have a key specified. Otherwise, conditional\r\n    * placeholders and conditional elements next to placeholders will cause\r\n    * placeholder elements to be re-used as non-placeholders and vice versa.\r\n    * @param {string} key\r\n    */\r\n  var assertPlaceholderKeySpecified = function(key) {\r\n    if (!key) {\r\n      throw new Error('Placeholder elements must have a key specified.');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n    * Makes sure that tags are correctly nested.\r\n    * @param {string} nodeName\r\n    * @param {string} tag\r\n    */\r\n  var assertCloseMatchesOpenTag = function(nodeName, tag) {\r\n    if (nodeName !== tag) {\r\n      throw new Error('Received a call to close ' + tag + ' but ' +\r\n          nodeName + ' was open.');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Updates the state to being in an attribute declaration.\r\n   * @param {boolean} value\r\n   */\r\n  var setInAttributes = function(value) {\r\n    inAttributes = value;\r\n  };\n\n  /**\r\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n   *\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *\r\n   *      http://www.apache.org/licenses/LICENSE-2.0\r\n   *\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n\r\n  /** */\r\n  exports.notifications = {\r\n    /**\r\n     * Called after patch has compleated with any Nodes that have been created\r\n     * and added to the DOM.\r\n     * @type {?function(Array<!Node>)}\r\n     */\r\n    nodesCreated: null,\r\n\r\n    /**\r\n     * Called after patch has compleated with any Nodes that have been removed\r\n     * from the DOM.\r\n     * Note it's an applications responsibility to handle any childNodes.\r\n     * @type {?function(Array<!Node>)}\r\n     */\r\n    nodesDeleted: null\r\n  };\n\n  /**\r\n   * Keeps track of the state of a patch.\r\n   * @constructor\r\n   */\r\n  function Context() {\r\n    /**\r\n     * @type {(Array<!Node>|undefined)}\r\n     */\r\n    this.created = exports.notifications.nodesCreated && [];\r\n\r\n    /**\r\n     * @type {(Array<!Node>|undefined)}\r\n     */\r\n    this.deleted = exports.notifications.nodesDeleted && [];\r\n  }\r\n\r\n\r\n  /**\r\n   * @param {!Node} node\r\n   */\r\n  Context.prototype.markCreated = function(node) {\r\n    if (this.created) {\r\n      this.created.push(node);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @param {!Node} node\r\n   */\r\n  Context.prototype.markDeleted = function(node) {\r\n    if (this.deleted) {\r\n      this.deleted.push(node);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Notifies about nodes that were created during the patch opearation.\r\n   */\r\n  Context.prototype.notifyChanges = function() {\r\n    if (this.created && this.created.length > 0) {\r\n      exports.notifications.nodesCreated(this.created);\r\n    }\r\n\r\n    if (this.deleted && this.deleted.length > 0) {\r\n      exports.notifications.nodesDeleted(this.deleted);\r\n    }\r\n  };\n\n  /**\r\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n   *\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *\r\n   *      http://www.apache.org/licenses/LICENSE-2.0\r\n   *\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n\r\n\r\n  /**\r\n   * A cached reference to the hasOwnProperty function.\r\n   */\r\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n\r\n  /**\r\n   * A cached reference to the create function.\r\n   */\r\n  var create = Object.create;\r\n\r\n\r\n  /**\r\n   * Used to prevent property collisions between our \"map\" and its prototype.\r\n   * @param {!Object<string, *>} map The map to check.\r\n   * @param {string} property The property to check.\r\n   * @return {boolean} Whether map has property.\r\n   */\r\n  var has = function(map, property) {\r\n    return hasOwnProperty.call(map, property);\r\n  };\r\n\r\n\r\n  /**\r\n   * Creates an map object without a prototype.\r\n   * @return {!Object}\r\n   */\r\n  var createMap = function() {\r\n    return create(null);\r\n  };\n\n  /**\r\n   * Keeps track of information needed to perform diffs for a given DOM node.\r\n   * @param {!string} nodeName\r\n   * @param {?string=} key\r\n   * @constructor\r\n   */\r\n  function NodeData(nodeName, key) {\r\n    /**\r\n     * The attributes and their values.\r\n     * @const\r\n     */\r\n    this.attrs = createMap();\r\n\r\n    /**\r\n     * An array of attribute name/value pairs, used for quickly diffing the\r\n     * incomming attributes to see if the DOM node's attributes need to be\r\n     * updated.\r\n     * @const {Array<*>}\r\n     */\r\n    this.attrsArr = [];\r\n\r\n    /**\r\n     * The incoming attributes for this Node, before they are updated.\r\n     * @const {!Object<string, *>}\r\n     */\r\n    this.newAttrs = createMap();\r\n\r\n    /**\r\n     * The key used to identify this node, used to preserve DOM nodes when they\r\n     * move within their parent.\r\n     * @const\r\n     */\r\n    this.key = key;\r\n\r\n    /**\r\n     * Keeps track of children within this node by their key.\r\n     * {?Object<string, !Element>}\r\n     */\r\n    this.keyMap = null;\r\n\r\n    /**\r\n     * Whether or not the keyMap is currently valid.\r\n     * {boolean}\r\n     */\r\n    this.keyMapValid = true;\r\n\r\n    /**\r\n     * The node name for this node.\r\n     * @const {string}\r\n     */\r\n    this.nodeName = nodeName;\r\n\r\n    /**\r\n     * @type {?string}\r\n     */\r\n    this.text = null;\r\n  }\r\n\r\n\r\n  /**\r\n   * Initializes a NodeData object for a Node.\r\n   *\r\n   * @param {Node} node The node to initialize data for.\r\n   * @param {string} nodeName The node name of node.\r\n   * @param {?string=} key The key that identifies the node.\r\n   * @return {!NodeData} The newly initialized data object\r\n   */\r\n  var initData = function(node, nodeName, key) {\r\n    var data = new NodeData(nodeName, key);\r\n    node['__incrementalDOMData'] = data;\r\n    return data;\r\n  };\r\n\r\n\r\n  /**\r\n   * Retrieves the NodeData object for a Node, creating it if necessary.\r\n   *\r\n   * @param {Node} node The node to retrieve the data for.\r\n   * @return {!NodeData} The NodeData for this Node.\r\n   */\r\n  var getData = function(node) {\r\n    var data = node['__incrementalDOMData'];\r\n\r\n    if (!data) {\r\n      var nodeName = node.nodeName.toLowerCase();\r\n      var key = null;\r\n\r\n      if (node instanceof Element) {\r\n        key = node.getAttribute('key');\r\n      }\r\n\r\n      data = initData(node, nodeName, key);\r\n    }\r\n\r\n    return data;\r\n  };\n\n  /**\r\n   * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n   *\r\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   * you may not use this file except in compliance with the License.\r\n   * You may obtain a copy of the License at\r\n   *\r\n   *      http://www.apache.org/licenses/LICENSE-2.0\r\n   *\r\n   * Unless required by applicable law or agreed to in writing, software\r\n   * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   * See the License for the specific language governing permissions and\r\n   * limitations under the License.\r\n   */\r\n\r\n  exports.symbols = {\r\n    default: '__default',\r\n\r\n    placeholder: '__placeholder'\r\n  };\n\n  /**\r\n   * Applies an attribute or property to a given Element. If the value is null\r\n   * or undefined, it is removed from the Element. Otherwise, the value is set\r\n   * as an attribute.\r\n   * @param {!Element} el\r\n   * @param {string} name The attribute's name.\r\n   * @param {?(boolean|number|string)=} value The attribute's value.\r\n   */\r\n  exports.applyAttr = function(el, name, value) {\r\n    if (value == null) {\r\n      el.removeAttribute(name);\r\n    } else {\r\n      el.setAttribute(name, value);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Applies a property to a given Element.\r\n   * @param {!Element} el\r\n   * @param {string} name The property's name.\r\n   * @param {*} value The property's value.\r\n   */\r\n  exports.applyProp = function(el, name, value) {\r\n    el[name] = value;\r\n  };\r\n\r\n\r\n  /**\r\n   * Applies a style to an Element. No vendor prefix expansion is done for\r\n   * property names/values.\r\n   * @param {!Element} el\r\n   * @param {string} name The attribute's name.\r\n   * @param {string|Object<string,string>} style The style to set. Either a\r\n   *     string of css or an object containing property-value pairs.\r\n   */\r\n  var applyStyle = function(el, name, style) {\r\n    if (typeof style === 'string') {\r\n      el.style.cssText = style;\r\n    } else {\r\n      el.style.cssText = '';\r\n      var elStyle = el.style;\r\n\r\n      for (var prop in style) {\r\n        if (has(style, prop)) {\r\n          elStyle[prop] = style[prop];\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Updates a single attribute on an Element.\r\n   * @param {!Element} el\r\n   * @param {string} name The attribute's name.\r\n   * @param {*} value The attribute's value. If the value is an object or\r\n   *     function it is set on the Element, otherwise, it is set as an HTML\r\n   *     attribute.\r\n   */\r\n  var applyAttributeTyped = function(el, name, value) {\r\n    var type = typeof value;\r\n\r\n    if (type === 'object' || type === 'function') {\r\n      exports.applyProp(el, name, value);\r\n    } else {\r\n      exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Calls the appropriate attribute mutator for this attribute.\r\n   * @param {!Element} el\r\n   * @param {string} name The attribute's name.\r\n   * @param {*} value The attribute's value.\r\n   */\r\n  var updateAttribute = function(el, name, value) {\r\n    var data = getData(el);\r\n    var attrs = data.attrs;\r\n\r\n    if (attrs[name] === value) {\r\n      return;\r\n    }\r\n\r\n    var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\r\n    mutator(el, name, value);\r\n\r\n    attrs[name] = value;\r\n  };\r\n\r\n\r\n  /**\r\n   * A publicly mutable object to provide custom mutators for attributes.\r\n   * @const {!Object<string, function(!Element, string, *)>}\r\n   */\r\n  exports.attributes = createMap();\r\n\r\n  // Special generic mutator that's called for any attribute that does not\r\n  // have a specific mutator.\r\n  exports.attributes[exports.symbols.default] = applyAttributeTyped;\r\n\r\n  exports.attributes[exports.symbols.placeholder] = function() {};\r\n\r\n  exports.attributes['style'] = applyStyle;\n\n  /**\r\n   * Gets the namespace to create an element (of a given tag) in.\r\n   * @param {string} tag The tag to get the namespace for.\r\n   * @param {!Node} parent\r\n   * @return {?string} The namespace to create the tag in.\r\n   */\r\n  var getNamespaceForTag = function(tag, parent) {\r\n    if (tag === 'svg') {\r\n      return 'http://www.w3.org/2000/svg';\r\n    }\r\n\r\n    if (getData(parent).nodeName === 'foreignObject') {\r\n      return null;\r\n    }\r\n\r\n    return parent.namespaceURI;\r\n  };\r\n\r\n\r\n  /**\r\n   * Creates an Element.\r\n   * @param {Document} doc The document with which to create the Element.\r\n   * @param {string} tag The tag for the Element.\r\n   * @param {?string=} key A key to identify the Element.\r\n   * @param {!Node} parent\r\n   * @return {!Element}\r\n   */\r\n  var createElement = function(doc, tag, key, parent) {\r\n    var namespace = getNamespaceForTag(tag, parent);\r\n    var el;\r\n\r\n    if (namespace) {\r\n      el = doc.createElementNS(namespace, tag);\r\n    } else {\r\n      el = doc.createElement(tag);\r\n    }\r\n\r\n    return el;\r\n  };\r\n\r\n\r\n  /**\r\n   * Creates a Node, either a Text or an Element depending on the node name\r\n   * provided.\r\n   * @param {Document} doc The document with which to create the Node.\r\n   * @param {string} nodeName The tag if creating an element or #text to create\r\n   *     a Text.\r\n   * @param {?string=} key A key to identify the Element.\r\n   * @param {?Array<*>=} statics The static data to initialize the Node\r\n   *     with. For an Element, an array of attribute name/value pairs of\r\n   *     the static attributes for the Element.\r\n   * @param {!Node} parent\r\n   * @return {!Node}\r\n   */\r\n  var createNode = function(doc, nodeName, key, statics, parent) {\r\n    var node;\r\n    if (nodeName === '#text') {\r\n      node = doc.createTextNode('');\r\n    } else {\r\n      node = createElement(doc, nodeName, key, parent);\r\n    }\r\n\r\n    initData(node, nodeName, key);\r\n\r\n    if (statics) {\r\n      for (var i = 0; i < statics.length; i += 2) {\r\n        updateAttribute(/** @type {!Element}*/(node),\r\n                        /** @type {!string}*/(statics[i]),\r\n                        statics[i + 1]);\r\n      }\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Creates a mapping that can be used to look up children using a key.\r\n   * @param {!Node} el\r\n   * @return {!Object<string, !Element>} A mapping of keys to the children of the\r\n   *     Element.\r\n   */\r\n  var createKeyMap = function(el) {\r\n    var map = createMap();\r\n    var children = el.children;\r\n    var count = children.length;\r\n\r\n    for (var i = 0; i < count; i += 1) {\r\n      var child = children[i];\r\n      var key = getData(child).key;\r\n\r\n      if (key) {\r\n        map[key] = child;\r\n      }\r\n    }\r\n\r\n    return map;\r\n  };\r\n\r\n\r\n  /**\r\n   * Retrieves the mapping of key to child node for a given Element, creating it\r\n   * if necessary.\r\n   * @param {!Node} el\r\n   * @return {!Object<string, !Node>} A mapping of keys to child Elements\r\n   */\r\n  var getKeyMap = function(el) {\r\n    var data = getData(el);\r\n\r\n    if (!data.keyMap) {\r\n      data.keyMap = createKeyMap(el);\r\n    }\r\n\r\n    return data.keyMap;\r\n  };\r\n\r\n\r\n  /**\r\n   * Retrieves a child from the parent with the given key.\r\n   * @param {!Node} parent\r\n   * @param {?string=} key\r\n   * @return {?Element} The child corresponding to the key.\r\n   */\r\n  var getChild = function(parent, key) {\r\n    return getKeyMap(parent)[key];\r\n  };\r\n\r\n\r\n  /**\r\n   * Registers an element as being a child. The parent will keep track of the\r\n   * child using the key. The child can be retrieved using the same key using\r\n   * getKeyMap. The provided key should be unique within the parent Element.\r\n   * @param {!Node} parent The parent of child.\r\n   * @param {string} key A key to identify the child with.\r\n   * @param {!Node} child The child to register.\r\n   */\r\n  var registerChild = function(parent, key, child) {\r\n    getKeyMap(parent)[key] = child;\r\n  };\n\n  /** @type {?Context} */\r\n  var context = null;\r\n\r\n  /** @type {?Node} */\r\n  var currentNode;\r\n\r\n  /** @type {?Node} */\r\n  var currentParent;\r\n\r\n  /** @type {?Node} */\r\n  var previousNode;\r\n\r\n  /** @type {?Element|?DocumentFragment} */\r\n  var root;\r\n\r\n  /** @type {?Document} */\r\n  var doc;\r\n\r\n\r\n  /**\r\n   * Patches the document starting at el with the provided function. This function\r\n   * may be called during an existing patch operation.\r\n   * @param {!Element|!DocumentFragment} node The Element or Document\r\n   *     to patch.\r\n   * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\r\n   *     calls that describe the DOM.\r\n   * @param {T=} data An argument passed to fn to represent DOM state.\r\n   * @template T\r\n   */\r\n  exports.patch = function(node, fn, data) {\r\n    var prevContext = context;\r\n    var prevRoot = root;\r\n    var prevDoc = doc;\r\n    var prevCurrentNode = currentNode;\r\n    var prevCurrentParent = currentParent;\r\n    var prevPreviousNode = previousNode;\r\n\r\n    context = new Context(node);\r\n    root = node;\r\n    doc = node.ownerDocument;\r\n    currentNode = node;\r\n    currentParent = null;\r\n    previousNode = null;\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      setInAttributes(false);\r\n    }\r\n\r\n    enterNode();\r\n    fn(data);\r\n    exitNode();\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertVirtualAttributesClosed();\r\n      assertNoUnclosedTags(previousNode, node);\r\n    }\r\n\r\n    context.notifyChanges();\r\n\r\n    context = prevContext;\r\n    root = prevRoot;\r\n    doc = prevDoc;\r\n    currentNode = prevCurrentNode;\r\n    currentParent = prevCurrentParent;\r\n    previousNode = prevPreviousNode;\r\n  };\r\n\r\n\r\n  /**\r\n   * Checks whether or not the current node matches the specified nodeName and\r\n   * key.\r\n   *\r\n   * @param {?string} nodeName The nodeName for this node.\r\n   * @param {?string=} key An optional key that identifies a node.\r\n   * @return {boolean} True if the node matches, false otherwise.\r\n   */\r\n  var matches = function(nodeName, key) {\r\n    var data = getData(currentNode);\r\n\r\n    // Key check is done using double equals as we want to treat a null key the\r\n    // same as undefined. This should be okay as the only values allowed are\r\n    // strings, null and undefined so the == semantics are not too weird.\r\n    return nodeName === data.nodeName && key == data.key;\r\n  };\r\n\r\n\r\n  /**\r\n   * Aligns the virtual Element definition with the actual DOM, moving the\r\n   * corresponding DOM node to the correct location or creating it if necessary.\r\n   * @param {string} nodeName For an Element, this should be a valid tag string.\r\n   *     For a Text, this should be #text.\r\n   * @param {?string=} key The key used to identify this element.\r\n   * @param {?Array<*>=} statics For an Element, this should be an array of\r\n   *     name-value pairs.\r\n   */\r\n  var alignWithDOM = function(nodeName, key, statics) {\r\n    if (currentNode && matches(nodeName, key)) {\r\n      return;\r\n    }\r\n\r\n    var node;\r\n\r\n    // Check to see if the node has moved within the parent.\r\n    if (key) {\r\n      node = getChild(currentParent, key);\r\n      if (node && process.env.NODE_ENV !== 'production') {\r\n        assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\r\n      }\r\n    }\r\n\r\n    // Create the node if it doesn't exist.\r\n    if (!node) {\r\n      node = createNode(doc, nodeName, key, statics, currentParent);\r\n\r\n      if (key) {\r\n        registerChild(currentParent, key, node);\r\n      }\r\n\r\n      context.markCreated(node);\r\n    }\r\n\r\n    // If the node has a key, remove it from the DOM to prevent a large number\r\n    // of re-orders in the case that it moved far or was completely removed.\r\n    // Since we hold on to a reference through the keyMap, we can always add it\r\n    // back.\r\n    if (currentNode && getData(currentNode).key) {\r\n      currentParent.replaceChild(node, currentNode);\r\n      getData(currentParent).keyMapValid = false;\r\n    } else {\r\n      currentParent.insertBefore(node, currentNode);\r\n    }\r\n\r\n    currentNode = node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Clears out any unvisited Nodes, as the corresponding virtual element\r\n   * functions were never called for them.\r\n   */\r\n  var clearUnvisitedDOM = function() {\r\n    var node = currentParent;\r\n    var data = getData(node);\r\n    var keyMap = data.keyMap;\r\n    var keyMapValid = data.keyMapValid;\r\n    var child = node.lastChild;\r\n    var key;\r\n\r\n    if (child === previousNode && keyMapValid) {\r\n      return;\r\n    }\r\n\r\n    if (data.attrs[exports.symbols.placeholder] && node !== root) {\r\n      return;\r\n    }\r\n\r\n    while (child !== previousNode) {\r\n      node.removeChild(child);\r\n      context.markDeleted(/** @type {!Node}*/(child));\r\n\r\n      key = getData(child).key;\r\n      if (key) {\r\n        delete keyMap[key];\r\n      }\r\n      child = node.lastChild;\r\n    }\r\n\r\n    // Clean the keyMap, removing any unusued keys.\r\n    if (!keyMapValid) {\r\n      for (key in keyMap) {\r\n        child = keyMap[key];\r\n        if (child.parentNode !== node) {\r\n          context.markDeleted(child);\r\n          delete keyMap[key];\r\n        }\r\n      }\r\n\r\n      data.keyMapValid = true;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Changes to the first child of the current node.\r\n   */\r\n  var enterNode = function() {\r\n    currentParent = currentNode;\r\n    currentNode = currentNode.firstChild;\r\n    previousNode = null;\r\n  };\r\n\r\n\r\n  /**\r\n   * Changes to the next sibling of the current node.\r\n   */\r\n  var nextNode = function() {\r\n    previousNode = currentNode;\r\n    currentNode = currentNode.nextSibling;\r\n  };\r\n\r\n\r\n  /**\r\n   * Changes to the parent of the current node, removing any unvisited children.\r\n   */\r\n  var exitNode = function() {\r\n    clearUnvisitedDOM();\r\n\r\n    previousNode = currentParent;\r\n    currentNode = currentParent.nextSibling;\r\n    currentParent = currentParent.parentNode;\r\n  };\r\n\r\n\r\n  /**\r\n   * Makes sure that the current node is an Element with a matching tagName and\r\n   * key.\r\n   *\r\n   * @param {string} tag The element's tag.\r\n   * @param {?string=} key The key used to identify this element. This can be an\r\n   *     empty string, but performance may be better if a unique value is used\r\n   *     when iterating over an array of items.\r\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n   *     static attributes for the Element. These will only be set once when the\r\n   *     Element is created.\r\n   * @return {!Element} The corresponding Element.\r\n   */\r\n  var _elementOpen = function(tag, key, statics) {\r\n    alignWithDOM(tag, key, statics);\r\n    enterNode();\r\n    return /** @type {!Element} */(currentParent);\r\n  };\r\n\r\n\r\n  /**\r\n   * Closes the currently open Element, removing any unvisited children if\r\n   * necessary.\r\n   *\r\n   * @return {!Element} The corresponding Element.\r\n   */\r\n  var _elementClose = function() {\r\n    exitNode();\r\n    return /** @type {!Element} */(previousNode);\r\n  };\r\n\r\n\r\n  /**\r\n   * Makes sure the current node is a Text node and creates a Text node if it is\r\n   * not.\r\n   *\r\n   * @return {!Text} The corresponding Text Node.\r\n   */\r\n  var _text = function() {\r\n    alignWithDOM('#text', null, null);\r\n    nextNode();\r\n    return /** @type {!Text} */(previousNode);\r\n  };\r\n\r\n\r\n  /**\r\n   * Gets the current Element being patched.\r\n   * @return {!Element}\r\n   */\r\n  exports.currentElement = function() {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertInPatch(context);\r\n      assertNotInAttributes('currentElement');\r\n    }\r\n    return /** @type {!Element} */(currentParent);\r\n  };\r\n\r\n\r\n  /**\r\n   * Skips the children in a subtree, allowing an Element to be closed without\r\n   * clearing out the children.\r\n   */\r\n  exports.skip = function() {\r\n    previousNode = currentParent.lastChild;\r\n  };\n\n  /**\r\n   * The offset in the virtual element declaration where the attributes are\r\n   * specified.\r\n   * @const\r\n   */\r\n  var ATTRIBUTES_OFFSET = 3;\r\n\r\n\r\n  /**\r\n   * Builds an array of arguments for use with elementOpenStart, attr and\r\n   * elementOpenEnd.\r\n   * @const {Array<*>}\r\n   */\r\n  var argsBuilder = [];\r\n\r\n\r\n  /**\r\n   * @param {string} tag The element's tag.\r\n   * @param {?string=} key The key used to identify this element. This can be an\r\n   *     empty string, but performance may be better if a unique value is used\r\n   *     when iterating over an array of items.\r\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n   *     static attributes for the Element. These will only be set once when the\r\n   *     Element is created.\r\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\r\n   *     for the Element.\r\n   * @return {!Element} The corresponding Element.\r\n   */\r\n  exports.elementOpen = function(tag, key, statics, var_args) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotInAttributes('elementOpen');\r\n    }\r\n\r\n    var node = _elementOpen(tag, key, statics);\r\n    var data = getData(node);\r\n\r\n    /*\r\n     * Checks to see if one or more attributes have changed for a given Element.\r\n     * When no attributes have changed, this is much faster than checking each\r\n     * individual argument. When attributes have changed, the overhead of this is\r\n     * minimal.\r\n     */\r\n    var attrsArr = data.attrsArr;\r\n    var newAttrs = data.newAttrs;\r\n    var attrsChanged = false;\r\n    var i = ATTRIBUTES_OFFSET;\r\n    var j = 0;\r\n\r\n    for (; i < arguments.length; i += 1, j += 1) {\r\n      if (attrsArr[j] !== arguments[i]) {\r\n        attrsChanged = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    for (; i < arguments.length; i += 1, j += 1) {\r\n      attrsArr[j] = arguments[i];\r\n    }\r\n\r\n    if (j < attrsArr.length) {\r\n      attrsChanged = true;\r\n      attrsArr.length = j;\r\n    }\r\n\r\n    /*\r\n     * Actually perform the attribute update.\r\n     */\r\n    if (attrsChanged) {\r\n      for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\r\n        newAttrs[arguments[i]] = arguments[i + 1];\r\n      }\r\n\r\n      for (var attr in newAttrs) {\r\n        updateAttribute(node, attr, newAttrs[attr]);\r\n        newAttrs[attr] = undefined;\r\n      }\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Declares a virtual Element at the current location in the document. This\r\n   * corresponds to an opening tag and a elementClose tag is required. This is\r\n   * like elementOpen, but the attributes are defined using the attr function\r\n   * rather than being passed as arguments. Must be folllowed by 0 or more calls\r\n   * to attr, then a call to elementOpenEnd.\r\n   * @param {string} tag The element's tag.\r\n   * @param {?string=} key The key used to identify this element. This can be an\r\n   *     empty string, but performance may be better if a unique value is used\r\n   *     when iterating over an array of items.\r\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n   *     static attributes for the Element. These will only be set once when the\r\n   *     Element is created.\r\n   */\r\n  exports.elementOpenStart = function(tag, key, statics) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotInAttributes('elementOpenStart');\r\n      setInAttributes(true);\r\n    }\r\n\r\n    argsBuilder[0] = tag;\r\n    argsBuilder[1] = key;\r\n    argsBuilder[2] = statics;\r\n  };\r\n\r\n\r\n  /***\r\n   * Defines a virtual attribute at this point of the DOM. This is only valid\r\n   * when called between elementOpenStart and elementOpenEnd.\r\n   *\r\n   * @param {string} name\r\n   * @param {*} value\r\n   */\r\n  exports.attr = function(name, value) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertInAttributes('attr');\r\n    }\r\n\r\n    argsBuilder.push(name, value);\r\n  };\r\n\r\n\r\n  /**\r\n   * Closes an open tag started with elementOpenStart.\r\n   * @return {!Element} The corresponding Element.\r\n   */\r\n  exports.elementOpenEnd = function() {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertInAttributes('elementOpenEnd');\r\n      setInAttributes(false);\r\n    }\r\n\r\n    var node = exports.elementOpen.apply(null, argsBuilder);\r\n    argsBuilder.length = 0;\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Closes an open virtual Element.\r\n   *\r\n   * @param {string} tag The element's tag.\r\n   * @return {!Element} The corresponding Element.\r\n   */\r\n  exports.elementClose = function(tag) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotInAttributes('elementClose');\r\n    }\r\n\r\n    var node = _elementClose();\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertCloseMatchesOpenTag(getData(node).nodeName, tag);\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Declares a virtual Element at the current location in the document that has\r\n   * no children.\r\n   * @param {string} tag The element's tag.\r\n   * @param {?string=} key The key used to identify this element. This can be an\r\n   *     empty string, but performance may be better if a unique value is used\r\n   *     when iterating over an array of items.\r\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n   *     static attributes for the Element. These will only be set once when the\r\n   *     Element is created.\r\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\r\n   *     for the Element.\r\n   * @return {!Element} The corresponding Element.\r\n   */\r\n  exports.elementVoid = function(tag, key, statics, var_args) {\r\n    var node = exports.elementOpen.apply(null, arguments);\r\n    exports.elementClose.apply(null, arguments);\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Declares a virtual Element at the current location in the document that is a\r\n   * placeholder element. Children of this Element can be manually managed and\r\n   * will not be cleared by the library.\r\n   *\r\n   * A key must be specified to make sure that this node is correctly preserved\r\n   * across all conditionals.\r\n   *\r\n   * @param {string} tag The element's tag.\r\n   * @param {string} key The key used to identify this element.\r\n   * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n   *     static attributes for the Element. These will only be set once when the\r\n   *     Element is created.\r\n   * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\r\n   *     for the Element.\r\n   * @return {!Element} The corresponding Element.\r\n   */\r\n  exports.elementPlaceholder = function(tag, key, statics, var_args) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertPlaceholderKeySpecified(key);\r\n    }\r\n\r\n    exports.elementOpen.apply(null, arguments);\r\n    exports.skip();\r\n    return exports.elementClose.apply(null, arguments);\r\n  };\r\n\r\n\r\n  /**\r\n   * Declares a virtual Text at this point in the document.\r\n   *\r\n   * @param {string|number|boolean} value The value of the Text.\r\n   * @param {...(function((string|number|boolean)):string)} var_args\r\n   *     Functions to format the value which are called only when the value has\r\n   *     changed.\r\n   * @return {!Text} The corresponding text node.\r\n   */\r\n  exports.text = function(value, var_args) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      assertNotInAttributes('text');\r\n    }\r\n\r\n    var node = _text();\r\n    var data = getData(node);\r\n\r\n    if (data.text !== value) {\r\n      data.text = /** @type {string} */(value);\r\n\r\n      var formatted = value;\r\n      for (var i = 1; i < arguments.length; i += 1) {\r\n        formatted = arguments[i](formatted);\r\n      }\r\n\r\n      node.data = formatted;\r\n    }\r\n\r\n    return node;\r\n  };\n\n}));\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n/**\r\n  * Keeps track whether or not we are in an attributes declaration (after\r\n  * elementOpenStart, but before elementOpenEnd).\r\n  * @type {boolean}\r\n  */\r\nvar inAttributes = false;\r\n\r\n\r\n/**\r\n * Makes sure that there is a current patch context.\r\n * @param {*} context\r\n */\r\nvar assertInPatch = function(context) {\r\n  if (!context) {\r\n    throw new Error('Cannot call currentElement() unless in patch');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n* Makes sure that keyed Element matches the tag name provided.\r\n* @param {!Element} nodeName The nodeName of the node that is being matched.\r\n* @param {string=} tag The tag name of the Element.\r\n* @param {?string=} key The key of the Element.\r\n*/\r\nvar assertKeyedTagMatches = function(nodeName, tag, key) {\r\n  if (nodeName !== tag) {\r\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\r\n        tag + ', not a ' + nodeName + '.');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Makes sure that a patch closes every node that it opened.\r\n * @param {!Node} openElement\r\n * @param {!Node|!DocumentFragment} root\r\n */\r\nvar assertNoUnclosedTags = function(openElement, root) {\r\n  if (openElement === root) {\r\n    return;\r\n  }\r\n\r\n  var openTags = [];\r\n  while (openElement && openElement !== root) {\r\n    openTags.push(openElement.nodeName.toLowerCase());\r\n    openElement = openElement.parentNode;\r\n  }\r\n\r\n  throw new Error('One or more tags were not closed:\\n' +\r\n      openTags.join('\\n'));\r\n};\r\n\r\n\r\n/**\r\n * Makes sure that the caller is not where attributes are expected.\r\n * @param {string} functionName\r\n */\r\nvar assertNotInAttributes = function(functionName) {\r\n  if (inAttributes) {\r\n    throw new Error(functionName + '() may not be called between ' +\r\n        'elementOpenStart() and elementOpenEnd().');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Makes sure that the caller is where attributes are expected.\r\n * @param {string} functionName\r\n */\r\nvar assertInAttributes = function(functionName) {\r\n  if (!inAttributes) {\r\n    throw new Error(functionName + '() must be called after ' +\r\n        'elementOpenStart().');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Makes sure the patch closes virtual attributes call\r\n */\r\nvar assertVirtualAttributesClosed = function() {\r\n  if (inAttributes) {\r\n    throw new Error('elementOpenEnd() must be called after calling ' +\r\n        'elementOpenStart().');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n  * Makes sure that placeholders have a key specified. Otherwise, conditional\r\n  * placeholders and conditional elements next to placeholders will cause\r\n  * placeholder elements to be re-used as non-placeholders and vice versa.\r\n  * @param {string} key\r\n  */\r\nvar assertPlaceholderKeySpecified = function(key) {\r\n  if (!key) {\r\n    throw new Error('Placeholder elements must have a key specified.');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n  * Makes sure that tags are correctly nested.\r\n  * @param {string} nodeName\r\n  * @param {string} tag\r\n  */\r\nvar assertCloseMatchesOpenTag = function(nodeName, tag) {\r\n  if (nodeName !== tag) {\r\n    throw new Error('Received a call to close ' + tag + ' but ' +\r\n        nodeName + ' was open.');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Updates the state to being in an attribute declaration.\r\n * @param {boolean} value\r\n */\r\nvar setInAttributes = function(value) {\r\n  inAttributes = value;\r\n};\r\n\r\n\r\n/** */\r\nexport {\r\n  assertInPatch,\r\n  assertKeyedTagMatches,\r\n  assertNoUnclosedTags,\r\n  assertNotInAttributes,\r\n  assertInAttributes,\r\n  assertPlaceholderKeySpecified,\r\n  assertCloseMatchesOpenTag,\r\n  assertVirtualAttributesClosed,\r\n  setInAttributes\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/** */\r\nvar notifications = {\r\n  /**\r\n   * Called after patch has compleated with any Nodes that have been created\r\n   * and added to the DOM.\r\n   * @type {?function(Array<!Node>)}\r\n   */\r\n  nodesCreated: null,\r\n\r\n  /**\r\n   * Called after patch has compleated with any Nodes that have been removed\r\n   * from the DOM.\r\n   * Note it's an applications responsibility to handle any childNodes.\r\n   * @type {?function(Array<!Node>)}\r\n   */\r\n  nodesDeleted: null\r\n};\r\n\r\nexport {\r\n  notifications\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { notifications } from './notifications';\r\n\r\n\r\n/**\r\n * Keeps track of the state of a patch.\r\n * @constructor\r\n */\r\nfunction Context() {\r\n  /**\r\n   * @type {(Array<!Node>|undefined)}\r\n   */\r\n  this.created = notifications.nodesCreated && [];\r\n\r\n  /**\r\n   * @type {(Array<!Node>|undefined)}\r\n   */\r\n  this.deleted = notifications.nodesDeleted && [];\r\n}\r\n\r\n\r\n/**\r\n * @param {!Node} node\r\n */\r\nContext.prototype.markCreated = function(node) {\r\n  if (this.created) {\r\n    this.created.push(node);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @param {!Node} node\r\n */\r\nContext.prototype.markDeleted = function(node) {\r\n  if (this.deleted) {\r\n    this.deleted.push(node);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Notifies about nodes that were created during the patch opearation.\r\n */\r\nContext.prototype.notifyChanges = function() {\r\n  if (this.created && this.created.length > 0) {\r\n    notifications.nodesCreated(this.created);\r\n  }\r\n\r\n  if (this.deleted && this.deleted.length > 0) {\r\n    notifications.nodesDeleted(this.deleted);\r\n  }\r\n};\r\n\r\n\r\n/** */\r\nexport {\r\n  Context\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\n/**\r\n * A cached reference to the hasOwnProperty function.\r\n */\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n\r\n/**\r\n * A cached reference to the create function.\r\n */\r\nvar create = Object.create;\r\n\r\n\r\n/**\r\n * Used to prevent property collisions between our \"map\" and its prototype.\r\n * @param {!Object<string, *>} map The map to check.\r\n * @param {string} property The property to check.\r\n * @return {boolean} Whether map has property.\r\n */\r\nvar has = function(map, property) {\r\n  return hasOwnProperty.call(map, property);\r\n};\r\n\r\n\r\n/**\r\n * Creates an map object without a prototype.\r\n * @return {!Object}\r\n */\r\nvar createMap = function() {\r\n  return create(null);\r\n};\r\n\r\n\r\n/** */\r\nexport {\r\n  createMap,\r\n  has\r\n};\r\n\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { createMap } from './util';\r\n\r\n\r\n/**\r\n * Keeps track of information needed to perform diffs for a given DOM node.\r\n * @param {!string} nodeName\r\n * @param {?string=} key\r\n * @constructor\r\n */\r\nfunction NodeData(nodeName, key) {\r\n  /**\r\n   * The attributes and their values.\r\n   * @const\r\n   */\r\n  this.attrs = createMap();\r\n\r\n  /**\r\n   * An array of attribute name/value pairs, used for quickly diffing the\r\n   * incomming attributes to see if the DOM node's attributes need to be\r\n   * updated.\r\n   * @const {Array<*>}\r\n   */\r\n  this.attrsArr = [];\r\n\r\n  /**\r\n   * The incoming attributes for this Node, before they are updated.\r\n   * @const {!Object<string, *>}\r\n   */\r\n  this.newAttrs = createMap();\r\n\r\n  /**\r\n   * The key used to identify this node, used to preserve DOM nodes when they\r\n   * move within their parent.\r\n   * @const\r\n   */\r\n  this.key = key;\r\n\r\n  /**\r\n   * Keeps track of children within this node by their key.\r\n   * {?Object<string, !Element>}\r\n   */\r\n  this.keyMap = null;\r\n\r\n  /**\r\n   * Whether or not the keyMap is currently valid.\r\n   * {boolean}\r\n   */\r\n  this.keyMapValid = true;\r\n\r\n  /**\r\n   * The node name for this node.\r\n   * @const {string}\r\n   */\r\n  this.nodeName = nodeName;\r\n\r\n  /**\r\n   * @type {?string}\r\n   */\r\n  this.text = null;\r\n}\r\n\r\n\r\n/**\r\n * Initializes a NodeData object for a Node.\r\n *\r\n * @param {Node} node The node to initialize data for.\r\n * @param {string} nodeName The node name of node.\r\n * @param {?string=} key The key that identifies the node.\r\n * @return {!NodeData} The newly initialized data object\r\n */\r\nvar initData = function(node, nodeName, key) {\r\n  var data = new NodeData(nodeName, key);\r\n  node['__incrementalDOMData'] = data;\r\n  return data;\r\n};\r\n\r\n\r\n/**\r\n * Retrieves the NodeData object for a Node, creating it if necessary.\r\n *\r\n * @param {Node} node The node to retrieve the data for.\r\n * @return {!NodeData} The NodeData for this Node.\r\n */\r\nvar getData = function(node) {\r\n  var data = node['__incrementalDOMData'];\r\n\r\n  if (!data) {\r\n    var nodeName = node.nodeName.toLowerCase();\r\n    var key = null;\r\n\r\n    if (node instanceof Element) {\r\n      key = node.getAttribute('key');\r\n    }\r\n\r\n    data = initData(node, nodeName, key);\r\n  }\r\n\r\n  return data;\r\n};\r\n\r\n\r\n/** */\r\nexport {\r\n  getData,\r\n  initData\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nvar symbols = {\r\n  default: '__default',\r\n\r\n  placeholder: '__placeholder'\r\n};\r\n\r\n/** */\r\nexport {\r\n  symbols\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { getData } from './node_data';\r\nimport { symbols } from './symbols';\r\nimport {\r\n  createMap,\r\n  has\r\n} from './util';\r\n\r\n\r\n/**\r\n * Applies an attribute or property to a given Element. If the value is null\r\n * or undefined, it is removed from the Element. Otherwise, the value is set\r\n * as an attribute.\r\n * @param {!Element} el\r\n * @param {string} name The attribute's name.\r\n * @param {?(boolean|number|string)=} value The attribute's value.\r\n */\r\nvar applyAttr = function(el, name, value) {\r\n  if (value == null) {\r\n    el.removeAttribute(name);\r\n  } else {\r\n    el.setAttribute(name, value);\r\n  }\r\n};\r\n\r\n/**\r\n * Applies a property to a given Element.\r\n * @param {!Element} el\r\n * @param {string} name The property's name.\r\n * @param {*} value The property's value.\r\n */\r\nvar applyProp = function(el, name, value) {\r\n  el[name] = value;\r\n};\r\n\r\n\r\n/**\r\n * Applies a style to an Element. No vendor prefix expansion is done for\r\n * property names/values.\r\n * @param {!Element} el\r\n * @param {string} name The attribute's name.\r\n * @param {string|Object<string,string>} style The style to set. Either a\r\n *     string of css or an object containing property-value pairs.\r\n */\r\nvar applyStyle = function(el, name, style) {\r\n  if (typeof style === 'string') {\r\n    el.style.cssText = style;\r\n  } else {\r\n    el.style.cssText = '';\r\n    var elStyle = el.style;\r\n\r\n    for (var prop in style) {\r\n      if (has(style, prop)) {\r\n        elStyle[prop] = style[prop];\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Updates a single attribute on an Element.\r\n * @param {!Element} el\r\n * @param {string} name The attribute's name.\r\n * @param {*} value The attribute's value. If the value is an object or\r\n *     function it is set on the Element, otherwise, it is set as an HTML\r\n *     attribute.\r\n */\r\nvar applyAttributeTyped = function(el, name, value) {\r\n  var type = typeof value;\r\n\r\n  if (type === 'object' || type === 'function') {\r\n    applyProp(el, name, value);\r\n  } else {\r\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Calls the appropriate attribute mutator for this attribute.\r\n * @param {!Element} el\r\n * @param {string} name The attribute's name.\r\n * @param {*} value The attribute's value.\r\n */\r\nvar updateAttribute = function(el, name, value) {\r\n  var data = getData(el);\r\n  var attrs = data.attrs;\r\n\r\n  if (attrs[name] === value) {\r\n    return;\r\n  }\r\n\r\n  var mutator = attributes[name] || attributes[symbols.default];\r\n  mutator(el, name, value);\r\n\r\n  attrs[name] = value;\r\n};\r\n\r\n\r\n/**\r\n * A publicly mutable object to provide custom mutators for attributes.\r\n * @const {!Object<string, function(!Element, string, *)>}\r\n */\r\nvar attributes = createMap();\r\n\r\n// Special generic mutator that's called for any attribute that does not\r\n// have a specific mutator.\r\nattributes[symbols.default] = applyAttributeTyped;\r\n\r\nattributes[symbols.placeholder] = function() {};\r\n\r\nattributes['style'] = applyStyle;\r\n\r\n\r\n/** */\r\nexport {\r\n  updateAttribute,\r\n  applyProp,\r\n  applyAttr,\r\n  attributes\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { updateAttribute } from './attributes';\r\nimport {\r\n    getData,\r\n    initData\r\n} from './node_data';\r\nimport { createMap } from './util';\r\n\r\n\r\n/**\r\n * Gets the namespace to create an element (of a given tag) in.\r\n * @param {string} tag The tag to get the namespace for.\r\n * @param {!Node} parent\r\n * @return {?string} The namespace to create the tag in.\r\n */\r\nvar getNamespaceForTag = function(tag, parent) {\r\n  if (tag === 'svg') {\r\n    return 'http://www.w3.org/2000/svg';\r\n  }\r\n\r\n  if (getData(parent).nodeName === 'foreignObject') {\r\n    return null;\r\n  }\r\n\r\n  return parent.namespaceURI;\r\n};\r\n\r\n\r\n/**\r\n * Creates an Element.\r\n * @param {Document} doc The document with which to create the Element.\r\n * @param {string} tag The tag for the Element.\r\n * @param {?string=} key A key to identify the Element.\r\n * @param {!Node} parent\r\n * @return {!Element}\r\n */\r\nvar createElement = function(doc, tag, key, parent) {\r\n  var namespace = getNamespaceForTag(tag, parent);\r\n  var el;\r\n\r\n  if (namespace) {\r\n    el = doc.createElementNS(namespace, tag);\r\n  } else {\r\n    el = doc.createElement(tag);\r\n  }\r\n\r\n  return el;\r\n};\r\n\r\n\r\n/**\r\n * Creates a Node, either a Text or an Element depending on the node name\r\n * provided.\r\n * @param {Document} doc The document with which to create the Node.\r\n * @param {string} nodeName The tag if creating an element or #text to create\r\n *     a Text.\r\n * @param {?string=} key A key to identify the Element.\r\n * @param {?Array<*>=} statics The static data to initialize the Node\r\n *     with. For an Element, an array of attribute name/value pairs of\r\n *     the static attributes for the Element.\r\n * @param {!Node} parent\r\n * @return {!Node}\r\n */\r\nvar createNode = function(doc, nodeName, key, statics, parent) {\r\n  var node;\r\n  if (nodeName === '#text') {\r\n    node = doc.createTextNode('');\r\n  } else {\r\n    node = createElement(doc, nodeName, key, parent);\r\n  }\r\n\r\n  initData(node, nodeName, key);\r\n\r\n  if (statics) {\r\n    for (var i = 0; i < statics.length; i += 2) {\r\n      updateAttribute(/** @type {!Element}*/(node),\r\n                      /** @type {!string}*/(statics[i]),\r\n                      statics[i + 1]);\r\n    }\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\n\r\n/**\r\n * Creates a mapping that can be used to look up children using a key.\r\n * @param {!Node} el\r\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\r\n *     Element.\r\n */\r\nvar createKeyMap = function(el) {\r\n  var map = createMap();\r\n  var children = el.children;\r\n  var count = children.length;\r\n\r\n  for (var i = 0; i < count; i += 1) {\r\n    var child = children[i];\r\n    var key = getData(child).key;\r\n\r\n    if (key) {\r\n      map[key] = child;\r\n    }\r\n  }\r\n\r\n  return map;\r\n};\r\n\r\n\r\n/**\r\n * Retrieves the mapping of key to child node for a given Element, creating it\r\n * if necessary.\r\n * @param {!Node} el\r\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\r\n */\r\nvar getKeyMap = function(el) {\r\n  var data = getData(el);\r\n\r\n  if (!data.keyMap) {\r\n    data.keyMap = createKeyMap(el);\r\n  }\r\n\r\n  return data.keyMap;\r\n};\r\n\r\n\r\n/**\r\n * Retrieves a child from the parent with the given key.\r\n * @param {!Node} parent\r\n * @param {?string=} key\r\n * @return {?Element} The child corresponding to the key.\r\n */\r\nvar getChild = function(parent, key) {\r\n  return getKeyMap(parent)[key];\r\n};\r\n\r\n\r\n/**\r\n * Registers an element as being a child. The parent will keep track of the\r\n * child using the key. The child can be retrieved using the same key using\r\n * getKeyMap. The provided key should be unique within the parent Element.\r\n * @param {!Node} parent The parent of child.\r\n * @param {string} key A key to identify the child with.\r\n * @param {!Node} child The child to register.\r\n */\r\nvar registerChild = function(parent, key, child) {\r\n  getKeyMap(parent)[key] = child;\r\n};\r\n\r\n\r\n/** */\r\nexport {\r\n  createNode,\r\n  getChild,\r\n  registerChild\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {\r\n  createNode,\r\n  getChild,\r\n  registerChild\r\n} from './nodes';\r\nimport { getData } from './node_data';\r\nimport { Context } from './context';\r\nimport { symbols } from './symbols';\r\nimport {\r\n  assertInPatch,\r\n  assertKeyedTagMatches,\r\n  assertNoUnclosedTags,\r\n  assertNotInAttributes,\r\n  assertVirtualAttributesClosed,\r\n  setInAttributes\r\n} from './assertions';\r\nimport { notifications } from './notifications';\r\n\r\n\r\n/** @type {?Context} */\r\nvar context = null;\r\n\r\n/** @type {?Node} */\r\nvar currentNode;\r\n\r\n/** @type {?Node} */\r\nvar currentParent;\r\n\r\n/** @type {?Node} */\r\nvar previousNode;\r\n\r\n/** @type {?Element|?DocumentFragment} */\r\nvar root;\r\n\r\n/** @type {?Document} */\r\nvar doc;\r\n\r\n\r\n/**\r\n * Patches the document starting at el with the provided function. This function\r\n * may be called during an existing patch operation.\r\n * @param {!Element|!DocumentFragment} node The Element or Document\r\n *     to patch.\r\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\r\n *     calls that describe the DOM.\r\n * @param {T=} data An argument passed to fn to represent DOM state.\r\n * @template T\r\n */\r\nvar patch = function(node, fn, data) {\r\n  var prevContext = context;\r\n  var prevRoot = root;\r\n  var prevDoc = doc;\r\n  var prevCurrentNode = currentNode;\r\n  var prevCurrentParent = currentParent;\r\n  var prevPreviousNode = previousNode;\r\n\r\n  context = new Context(node);\r\n  root = node;\r\n  doc = node.ownerDocument;\r\n  currentNode = node;\r\n  currentParent = null;\r\n  previousNode = null;\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    setInAttributes(false);\r\n  }\r\n\r\n  enterNode();\r\n  fn(data);\r\n  exitNode();\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertVirtualAttributesClosed();\r\n    assertNoUnclosedTags(previousNode, node);\r\n  }\r\n\r\n  context.notifyChanges();\r\n\r\n  context = prevContext;\r\n  root = prevRoot;\r\n  doc = prevDoc;\r\n  currentNode = prevCurrentNode;\r\n  currentParent = prevCurrentParent;\r\n  previousNode = prevPreviousNode;\r\n};\r\n\r\n\r\n/**\r\n * Checks whether or not the current node matches the specified nodeName and\r\n * key.\r\n *\r\n * @param {?string} nodeName The nodeName for this node.\r\n * @param {?string=} key An optional key that identifies a node.\r\n * @return {boolean} True if the node matches, false otherwise.\r\n */\r\nvar matches = function(nodeName, key) {\r\n  var data = getData(currentNode);\r\n\r\n  // Key check is done using double equals as we want to treat a null key the\r\n  // same as undefined. This should be okay as the only values allowed are\r\n  // strings, null and undefined so the == semantics are not too weird.\r\n  return nodeName === data.nodeName && key == data.key;\r\n};\r\n\r\n\r\n/**\r\n * Aligns the virtual Element definition with the actual DOM, moving the\r\n * corresponding DOM node to the correct location or creating it if necessary.\r\n * @param {string} nodeName For an Element, this should be a valid tag string.\r\n *     For a Text, this should be #text.\r\n * @param {?string=} key The key used to identify this element.\r\n * @param {?Array<*>=} statics For an Element, this should be an array of\r\n *     name-value pairs.\r\n */\r\nvar alignWithDOM = function(nodeName, key, statics) {\r\n  if (currentNode && matches(nodeName, key)) {\r\n    return;\r\n  }\r\n\r\n  var node;\r\n\r\n  // Check to see if the node has moved within the parent.\r\n  if (key) {\r\n    node = getChild(currentParent, key);\r\n    if (node && process.env.NODE_ENV !== 'production') {\r\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\r\n    }\r\n  }\r\n\r\n  // Create the node if it doesn't exist.\r\n  if (!node) {\r\n    node = createNode(doc, nodeName, key, statics, currentParent);\r\n\r\n    if (key) {\r\n      registerChild(currentParent, key, node);\r\n    }\r\n\r\n    context.markCreated(node);\r\n  }\r\n\r\n  // If the node has a key, remove it from the DOM to prevent a large number\r\n  // of re-orders in the case that it moved far or was completely removed.\r\n  // Since we hold on to a reference through the keyMap, we can always add it\r\n  // back.\r\n  if (currentNode && getData(currentNode).key) {\r\n    currentParent.replaceChild(node, currentNode);\r\n    getData(currentParent).keyMapValid = false;\r\n  } else {\r\n    currentParent.insertBefore(node, currentNode);\r\n  }\r\n\r\n  currentNode = node;\r\n};\r\n\r\n\r\n/**\r\n * Clears out any unvisited Nodes, as the corresponding virtual element\r\n * functions were never called for them.\r\n */\r\nvar clearUnvisitedDOM = function() {\r\n  var node = currentParent;\r\n  var data = getData(node);\r\n  var keyMap = data.keyMap;\r\n  var keyMapValid = data.keyMapValid;\r\n  var child = node.lastChild;\r\n  var key;\r\n\r\n  if (child === previousNode && keyMapValid) {\r\n    return;\r\n  }\r\n\r\n  if (data.attrs[symbols.placeholder] && node !== root) {\r\n    return;\r\n  }\r\n\r\n  while (child !== previousNode) {\r\n    node.removeChild(child);\r\n    context.markDeleted(/** @type {!Node}*/(child));\r\n\r\n    key = getData(child).key;\r\n    if (key) {\r\n      delete keyMap[key];\r\n    }\r\n    child = node.lastChild;\r\n  }\r\n\r\n  // Clean the keyMap, removing any unusued keys.\r\n  if (!keyMapValid) {\r\n    for (key in keyMap) {\r\n      child = keyMap[key];\r\n      if (child.parentNode !== node) {\r\n        context.markDeleted(child);\r\n        delete keyMap[key];\r\n      }\r\n    }\r\n\r\n    data.keyMapValid = true;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Changes to the first child of the current node.\r\n */\r\nvar enterNode = function() {\r\n  currentParent = currentNode;\r\n  currentNode = currentNode.firstChild;\r\n  previousNode = null;\r\n};\r\n\r\n\r\n/**\r\n * Changes to the next sibling of the current node.\r\n */\r\nvar nextNode = function() {\r\n  previousNode = currentNode;\r\n  currentNode = currentNode.nextSibling;\r\n};\r\n\r\n\r\n/**\r\n * Changes to the parent of the current node, removing any unvisited children.\r\n */\r\nvar exitNode = function() {\r\n  clearUnvisitedDOM();\r\n\r\n  previousNode = currentParent;\r\n  currentNode = currentParent.nextSibling;\r\n  currentParent = currentParent.parentNode;\r\n};\r\n\r\n\r\n/**\r\n * Makes sure that the current node is an Element with a matching tagName and\r\n * key.\r\n *\r\n * @param {string} tag The element's tag.\r\n * @param {?string=} key The key used to identify this element. This can be an\r\n *     empty string, but performance may be better if a unique value is used\r\n *     when iterating over an array of items.\r\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n *     static attributes for the Element. These will only be set once when the\r\n *     Element is created.\r\n * @return {!Element} The corresponding Element.\r\n */\r\nvar elementOpen = function(tag, key, statics) {\r\n  alignWithDOM(tag, key, statics);\r\n  enterNode();\r\n  return /** @type {!Element} */(currentParent);\r\n};\r\n\r\n\r\n/**\r\n * Closes the currently open Element, removing any unvisited children if\r\n * necessary.\r\n *\r\n * @return {!Element} The corresponding Element.\r\n */\r\nvar elementClose = function() {\r\n  exitNode();\r\n  return /** @type {!Element} */(previousNode);\r\n};\r\n\r\n\r\n/**\r\n * Makes sure the current node is a Text node and creates a Text node if it is\r\n * not.\r\n *\r\n * @return {!Text} The corresponding Text Node.\r\n */\r\nvar text = function() {\r\n  alignWithDOM('#text', null, null);\r\n  nextNode();\r\n  return /** @type {!Text} */(previousNode);\r\n};\r\n\r\n\r\n/**\r\n * Gets the current Element being patched.\r\n * @return {!Element}\r\n */\r\nvar currentElement = function() {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertInPatch(context);\r\n    assertNotInAttributes('currentElement');\r\n  }\r\n  return /** @type {!Element} */(currentParent);\r\n};\r\n\r\n\r\n/**\r\n * Skips the children in a subtree, allowing an Element to be closed without\r\n * clearing out the children.\r\n */\r\nvar skip = function() {\r\n  previousNode = currentParent.lastChild;\r\n};\r\n\r\n\r\n/** */\r\nexport {\r\n  elementOpen,\r\n  elementClose,\r\n  text,\r\n  patch,\r\n  currentElement,\r\n  skip\r\n};\r\n","/**\r\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {\r\n  elementOpen as coreElementOpen,\r\n  elementClose as coreElementClose,\r\n  text as coreText,\r\n  currentElement,\r\n  skip\r\n} from './core';\r\nimport { updateAttribute } from './attributes';\r\nimport { getData } from './node_data';\r\nimport { symbols } from './symbols';\r\nimport {\r\n  assertNotInAttributes,\r\n  assertInAttributes,\r\n  assertPlaceholderKeySpecified,\r\n  assertCloseMatchesOpenTag,\r\n  setInAttributes\r\n} from './assertions';\r\n\r\n\r\n/**\r\n * The offset in the virtual element declaration where the attributes are\r\n * specified.\r\n * @const\r\n */\r\nvar ATTRIBUTES_OFFSET = 3;\r\n\r\n\r\n/**\r\n * Builds an array of arguments for use with elementOpenStart, attr and\r\n * elementOpenEnd.\r\n * @const {Array<*>}\r\n */\r\nvar argsBuilder = [];\r\n\r\n\r\n/**\r\n * @param {string} tag The element's tag.\r\n * @param {?string=} key The key used to identify this element. This can be an\r\n *     empty string, but performance may be better if a unique value is used\r\n *     when iterating over an array of items.\r\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n *     static attributes for the Element. These will only be set once when the\r\n *     Element is created.\r\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\r\n *     for the Element.\r\n * @return {!Element} The corresponding Element.\r\n */\r\nvar elementOpen = function(tag, key, statics, var_args) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertNotInAttributes('elementOpen');\r\n  }\r\n\r\n  var node = coreElementOpen(tag, key, statics);\r\n  var data = getData(node);\r\n\r\n  /*\r\n   * Checks to see if one or more attributes have changed for a given Element.\r\n   * When no attributes have changed, this is much faster than checking each\r\n   * individual argument. When attributes have changed, the overhead of this is\r\n   * minimal.\r\n   */\r\n  var attrsArr = data.attrsArr;\r\n  var newAttrs = data.newAttrs;\r\n  var attrsChanged = false;\r\n  var i = ATTRIBUTES_OFFSET;\r\n  var j = 0;\r\n\r\n  for (; i < arguments.length; i += 1, j += 1) {\r\n    if (attrsArr[j] !== arguments[i]) {\r\n      attrsChanged = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (; i < arguments.length; i += 1, j += 1) {\r\n    attrsArr[j] = arguments[i];\r\n  }\r\n\r\n  if (j < attrsArr.length) {\r\n    attrsChanged = true;\r\n    attrsArr.length = j;\r\n  }\r\n\r\n  /*\r\n   * Actually perform the attribute update.\r\n   */\r\n  if (attrsChanged) {\r\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\r\n      newAttrs[arguments[i]] = arguments[i + 1];\r\n    }\r\n\r\n    for (var attr in newAttrs) {\r\n      updateAttribute(node, attr, newAttrs[attr]);\r\n      newAttrs[attr] = undefined;\r\n    }\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\n\r\n/**\r\n * Declares a virtual Element at the current location in the document. This\r\n * corresponds to an opening tag and a elementClose tag is required. This is\r\n * like elementOpen, but the attributes are defined using the attr function\r\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\r\n * to attr, then a call to elementOpenEnd.\r\n * @param {string} tag The element's tag.\r\n * @param {?string=} key The key used to identify this element. This can be an\r\n *     empty string, but performance may be better if a unique value is used\r\n *     when iterating over an array of items.\r\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n *     static attributes for the Element. These will only be set once when the\r\n *     Element is created.\r\n */\r\nvar elementOpenStart = function(tag, key, statics) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertNotInAttributes('elementOpenStart');\r\n    setInAttributes(true);\r\n  }\r\n\r\n  argsBuilder[0] = tag;\r\n  argsBuilder[1] = key;\r\n  argsBuilder[2] = statics;\r\n};\r\n\r\n\r\n/***\r\n * Defines a virtual attribute at this point of the DOM. This is only valid\r\n * when called between elementOpenStart and elementOpenEnd.\r\n *\r\n * @param {string} name\r\n * @param {*} value\r\n */\r\nvar attr = function(name, value) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertInAttributes('attr');\r\n  }\r\n\r\n  argsBuilder.push(name, value);\r\n};\r\n\r\n\r\n/**\r\n * Closes an open tag started with elementOpenStart.\r\n * @return {!Element} The corresponding Element.\r\n */\r\nvar elementOpenEnd = function() {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertInAttributes('elementOpenEnd');\r\n    setInAttributes(false);\r\n  }\r\n\r\n  var node = elementOpen.apply(null, argsBuilder);\r\n  argsBuilder.length = 0;\r\n  return node;\r\n};\r\n\r\n\r\n/**\r\n * Closes an open virtual Element.\r\n *\r\n * @param {string} tag The element's tag.\r\n * @return {!Element} The corresponding Element.\r\n */\r\nvar elementClose = function(tag) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertNotInAttributes('elementClose');\r\n  }\r\n\r\n  var node = coreElementClose();\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\n\r\n/**\r\n * Declares a virtual Element at the current location in the document that has\r\n * no children.\r\n * @param {string} tag The element's tag.\r\n * @param {?string=} key The key used to identify this element. This can be an\r\n *     empty string, but performance may be better if a unique value is used\r\n *     when iterating over an array of items.\r\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n *     static attributes for the Element. These will only be set once when the\r\n *     Element is created.\r\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\r\n *     for the Element.\r\n * @return {!Element} The corresponding Element.\r\n */\r\nvar elementVoid = function(tag, key, statics, var_args) {\r\n  var node = elementOpen.apply(null, arguments);\r\n  elementClose.apply(null, arguments);\r\n  return node;\r\n};\r\n\r\n\r\n/**\r\n * Declares a virtual Element at the current location in the document that is a\r\n * placeholder element. Children of this Element can be manually managed and\r\n * will not be cleared by the library.\r\n *\r\n * A key must be specified to make sure that this node is correctly preserved\r\n * across all conditionals.\r\n *\r\n * @param {string} tag The element's tag.\r\n * @param {string} key The key used to identify this element.\r\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\r\n *     static attributes for the Element. These will only be set once when the\r\n *     Element is created.\r\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\r\n *     for the Element.\r\n * @return {!Element} The corresponding Element.\r\n */\r\nvar elementPlaceholder = function(tag, key, statics, var_args) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertPlaceholderKeySpecified(key);\r\n  }\r\n\r\n  elementOpen.apply(null, arguments);\r\n  skip();\r\n  return elementClose.apply(null, arguments);\r\n};\r\n\r\n\r\n/**\r\n * Declares a virtual Text at this point in the document.\r\n *\r\n * @param {string|number|boolean} value The value of the Text.\r\n * @param {...(function((string|number|boolean)):string)} var_args\r\n *     Functions to format the value which are called only when the value has\r\n *     changed.\r\n * @return {!Text} The corresponding text node.\r\n */\r\nvar text = function(value, var_args) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    assertNotInAttributes('text');\r\n  }\r\n\r\n  var node = coreText();\r\n  var data = getData(node);\r\n\r\n  if (data.text !== value) {\r\n    data.text = /** @type {string} */(value);\r\n\r\n    var formatted = value;\r\n    for (var i = 1; i < arguments.length; i += 1) {\r\n      formatted = arguments[i](formatted);\r\n    }\r\n\r\n    node.data = formatted;\r\n  }\r\n\r\n  return node;\r\n};\r\n\r\n\r\n/** */\r\nexport {\r\n  elementOpenStart,\r\n  elementOpenEnd,\r\n  elementOpen,\r\n  elementVoid,\r\n  elementClose,\r\n  elementPlaceholder,\r\n  text,\r\n  attr\r\n};\r\n"],"sourceRoot":"/source/"}